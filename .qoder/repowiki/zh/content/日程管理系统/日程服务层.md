# 日程服务层

<cite>
**本文档引用的文件**
- [service.go](file://server/service/schedule/service.go)
- [interface.go](file://server/service/schedule/interface.go)
- [conflict_resolver.go](file://server/service/schedule/conflict_resolver.go)
- [constants.go](file://server/service/schedule/constants.go)
- [schedule.go](file://store/schedule.go)
- [schedule.go](file://store/db/postgres/schedule.go)
- [schedule_service.proto](file://proto/api/v1/schedule_service.proto)
- [schedule_service.go](file://server/router/api/v1/schedule_service.go)
- [recurrence.go](file://plugin/ai/schedule/recurrence.go)
- [error_class.go](file://plugin/ai/agent/error_class.go)
- [service_test.go](file://server/service/schedule/service_test.go)
- [conflict_resolver_test.go](file://server/service/schedule/conflict_resolver_test.go)
</cite>

## 目录
1. [简介](#简介)
2. [项目结构](#项目结构)
3. [核心组件](#核心组件)
4. [架构概览](#架构概览)
5. [详细组件分析](#详细组件分析)
6. [依赖关系分析](#依赖关系分析)
7. [性能考虑](#性能考虑)
8. [故障排除指南](#故障排除指南)
9. [结论](#结论)

## 简介

日程服务层是 Memos 系统中负责日程管理的核心业务逻辑层。该服务层提供了完整的日程生命周期管理功能，包括日程的创建、查询、更新和删除操作，支持重复事件的展开和冲突检测机制。服务层采用分层架构设计，将业务逻辑与存储层分离，提供了清晰的接口抽象和强大的扩展能力。

该服务层的主要特性包括：
- **重复规则展开**：支持每日、每周、每月等重复模式的日程展开
- **智能冲突检测**：提供单次冲突检查和递归冲突检查机制
- **时区处理**：支持多时区的日程管理和显示
- **事务处理**：通过数据库约束确保数据一致性
- **性能优化**：采用索引和缓存策略优化查询性能

## 项目结构

日程服务层位于 `server/service/schedule/` 目录下，采用模块化设计，每个文件负责特定的功能领域：

```mermaid
graph TB
subgraph "服务层 (server/service/schedule)"
A[service.go<br/>核心业务逻辑]
B[interface.go<br/>接口定义]
C[conflict_resolver.go<br/>冲突解决器]
D[constants.go<br/>常量定义]
end
subgraph "存储层 (store)"
E[schedule.go<br/>存储模型]
F[db/postgres/schedule.go<br/>PostgreSQL实现]
end
subgraph "协议定义 (proto)"
G[schedule_service.proto<br/>API定义]
end
subgraph "路由层 (server/router)"
H[schedule_service.go<br/>HTTP路由]
end
subgraph "工具层 (plugin/ai)"
I[recurrence.go<br/>重复规则解析]
end
A --> E
A --> I
C --> A
H --> A
G --> H
```

**图表来源**
- [service.go](file://server/service/schedule/service.go#L1-L737)
- [interface.go](file://server/service/schedule/interface.go#L1-L85)
- [schedule.go](file://store/schedule.go#L1-L176)

**章节来源**
- [service.go](file://server/service/schedule/service.go#L1-L737)
- [interface.go](file://server/service/schedule/interface.go#L1-L85)

## 核心组件

### 服务接口定义

服务层定义了清晰的接口契约，确保业务逻辑的可测试性和可维护性：

```mermaid
classDiagram
class Service {
<<interface>>
+FindSchedules(ctx, userID, start, end) []*ScheduleInstance
+CreateSchedule(ctx, userID, create) *store.Schedule
+UpdateSchedule(ctx, userID, id, update) *store.Schedule
+DeleteSchedule(ctx, userID, id) error
+CheckConflicts(ctx, userID, startTs, endTs, excludeIDs) []*store.Schedule
}
class ScheduleService {
-store Store
+FindSchedules(ctx, userID, start, end) []*ScheduleInstance
+CreateSchedule(ctx, userID, create) *store.Schedule
+UpdateSchedule(ctx, userID, id, update) *store.Schedule
+DeleteSchedule(ctx, userID, id) error
+CheckConflicts(ctx, userID, startTs, endTs, excludeIDs) []*store.Schedule
}
class Store {
<<interface>>
+CreateSchedule(ctx, create) *store.Schedule
+ListSchedules(ctx, find) []*store.Schedule
+GetSchedule(ctx, find) *store.Schedule
+UpdateSchedule(ctx, update) error
+DeleteSchedule(ctx, delete) error
}
Service <|.. ScheduleService
ScheduleService --> Store
```

**图表来源**
- [interface.go](file://server/service/schedule/interface.go#L13-L31)
- [service.go](file://server/service/schedule/service.go#L70-L86)

### 数据模型

服务层使用统一的数据模型来表示日程实体：

| 字段名 | 类型 | 描述 | 必填 |
|--------|------|------|------|
| ID | int32 | 数据库自增ID | 否 |
| UID | string | 唯一标识符 | 是 |
| CreatorID | int32 | 创建者ID | 是 |
| Title | string | 日程标题 | 是 |
| Description | string | 日程描述 | 否 |
| Location | string | 地点 | 否 |
| StartTs | int64 | 开始时间戳 | 是 |
| EndTs | *int64 | 结束时间戳 | 否 |
| AllDay | bool | 是否全天事件 | 是 |
| Timezone | string | 时区 | 是 |
| RecurrenceRule | *string | 重复规则JSON | 否 |
| RecurrenceEndTs | *int64 | 重复结束时间戳 | 否 |
| Reminders | *string | 提醒设置JSON | 否 |
| Payload | *string | 扩展数据 | 否 |

**章节来源**
- [interface.go](file://server/service/schedule/interface.go#L33-L48)
- [schedule.go](file://store/schedule.go#L8-L27)

## 架构概览

日程服务层采用经典的三层架构模式，实现了业务逻辑与数据访问的分离：

```mermaid
graph TB
subgraph "表现层"
API[API网关]
Web[Web界面]
end
subgraph "服务层"
Svc[ScheduleService<br/>核心业务逻辑]
CR[ConflictResolver<br/>冲突解决器]
end
subgraph "存储层"
Store[Store接口]
PG[PostgreSQL驱动]
SQLite[SQLite驱动]
end
subgraph "工具层"
Rec[RRule解析器]
TZ[时区工具]
end
API --> Svc
Web --> Svc
Svc --> Store
Svc --> CR
Svc --> Rec
Store --> PG
Store --> SQLite
CR --> Svc
Rec --> Svc
```

**图表来源**
- [service.go](file://server/service/schedule/service.go#L70-L86)
- [conflict_resolver.go](file://server/service/schedule/conflict_resolver.go#L15-L24)

### 控制流分析

服务层的典型工作流程如下：

```mermaid
sequenceDiagram
participant Client as 客户端
participant Service as ScheduleService
participant Store as Store层
participant DB as 数据库
participant Resolver as 冲突解决器
Client->>Service : 创建日程请求
Service->>Service : 验证输入参数
Service->>Service : 检查冲突
Service->>Resolver : 冲突检测
Resolver->>Store : 查询现有日程
Store->>DB : 执行SQL查询
DB-->>Store : 返回查询结果
Store-->>Resolver : 返回日程列表
Resolver-->>Service : 返回冲突结果
Service->>Service : 处理冲突或继续
Service->>Store : 创建新日程
Store->>DB : 执行插入操作
DB-->>Store : 返回成功
Store-->>Service : 返回创建结果
Service-->>Client : 返回创建结果
```

**图表来源**
- [service.go](file://server/service/schedule/service.go#L195-L302)
- [conflict_resolver.go](file://server/service/schedule/conflict_resolver.go#L46-L97)

## 详细组件分析

### 核心服务实现

#### 日程创建流程

日程创建是服务层最复杂的操作之一，涉及多个验证步骤和冲突检测：

```mermaid
flowchart TD
Start([开始创建日程]) --> ValidateInput["验证输入参数"]
ValidateInput --> CheckTitle{"标题是否为空?"}
CheckTitle --> |是| ReturnError["返回错误"]
CheckTitle --> |否| CheckTime{"时间参数是否有效?"}
CheckTime --> |否| ReturnError
CheckTime --> |是| SetTimezone["设置默认时区"]
SetTimezone --> MarshalReminders["序列化提醒设置"]
MarshalReminders --> CreateScheduleObj["创建Schedule对象"]
CreateScheduleObj --> CheckSingleConflict["检查单次冲突"]
CheckSingleConflict --> HasConflict{"是否有冲突?"}
HasConflict --> |是| ReturnConflictError["返回冲突错误"]
HasConflict --> |否| CheckRecurringConflict["检查重复冲突"]
CheckRecurringConflict --> HasRecurringConflict{"重复规则冲突?"}
HasRecurringConflict --> |是| ReturnRecurringConflict["返回重复冲突错误"]
HasRecurringConflict --> |否| InsertToDB["插入数据库"]
InsertToDB --> CheckDBConflict{"数据库约束冲突?"}
CheckDBConflict --> |是| ReturnDBConflict["返回数据库冲突错误"]
CheckDBConflict --> |否| ReturnSuccess["返回成功"]
ReturnError --> End([结束])
ReturnConflictError --> End
ReturnRecurringConflict --> End
ReturnDBConflict --> End
ReturnSuccess --> End
```

**图表来源**
- [service.go](file://server/service/schedule/service.go#L195-L302)

#### 日程查询与实例展开

服务层支持查询指定时间范围内的日程，并自动展开重复规则：

```mermaid
flowchart TD
QueryStart([开始查询]) --> GetSchedules["获取用户日程"]
GetSchedules --> CheckRecurring{"是否为重复日程?"}
CheckRecurring --> |是| ParseRule["解析重复规则"]
ParseRule --> GenerateInstances["生成实例时间戳"]
GenerateInstances --> FilterInstances["过滤时间范围内的实例"]
FilterInstances --> ConvertToInstance["转换为实例对象"]
CheckRecurring --> |否| CheckOverlap{"是否与查询范围重叠?"}
CheckOverlap --> |是| ConvertToInstance
CheckOverlap --> |否| Skip["跳过该日程"]
ConvertToInstance --> CheckLimit{"实例数量是否超过限制?"}
CheckLimit --> |是| Truncate["截断并记录警告"]
CheckLimit --> |否| Continue["继续处理下一个"]
Continue --> GetSchedules
Skip --> GetSchedules
Truncate --> End([结束])
End --> End
```

**图表来源**
- [service.go](file://server/service/schedule/service.go#L88-L192)

**章节来源**
- [service.go](file://server/service/schedule/service.go#L88-L192)
- [service.go](file://server/service/schedule/service.go#L195-L302)

### 冲突检测机制

#### 单次冲突检查

单次冲突检查用于验证新创建或更新的日程是否与现有日程冲突：

```mermaid
flowchart TD
Start([开始冲突检查]) --> SetEndTime["确定检查结束时间"]
SetEndTime --> QueryPotential["查询潜在冲突日程"]
QueryPotential --> FilterExcluded["过滤排除的日程"]
FilterExcluded --> CheckOverlap{"检查时间重叠"}
CheckOverlap --> |重叠| AddToConflicts["添加到冲突列表"]
CheckOverlap --> |不重叠| NextSchedule["检查下一个日程"]
AddToConflicts --> NextSchedule
NextSchedule --> MoreSchedules{"还有更多日程?"}
MoreSchedules --> |是| CheckOverlap
MoreSchedules --> |否| ReturnConflicts["返回冲突结果"]
ReturnConflicts --> End([结束])
```

**图表来源**
- [service.go](file://server/service/schedule/service.go#L427-L480)

#### 递归冲突检查

递归冲突检查专门用于验证重复日程规则的有效性：

```mermaid
flowchart TD
Start([开始递归冲突检查]) --> ParseRule["解析重复规则"]
ParseRule --> SetEndTs["设置检查结束时间"]
SetEndTs --> QueryPotential["查询潜在冲突日程"]
QueryPotential --> BuildIndex["构建冲突索引"]
BuildIndex --> CreateIterator["创建迭代器"]
CreateIterator --> CheckInstances["逐个检查实例"]
CheckInstances --> CheckIndex{"索引中是否有冲突?"}
CheckIndex --> |是| FindConflicting["查找冲突的具体日程"]
CheckIndex --> |否| NextInstance["检查下一个实例"]
FindConflicting --> ReturnConflict["返回冲突详情"]
NextInstance --> MoreInstances{"还有更多实例?"}
MoreInstances --> |是| CheckIndex
MoreInstances --> |否| NoConflict["无冲突"]
ReturnConflict --> End([结束])
NoConflict --> End
```

**图表来源**
- [service.go](file://server/service/schedule/service.go#L548-L639)

**章节来源**
- [service.go](file://server/service/schedule/service.go#L427-L480)
- [service.go](file://server/service/schedule/service.go#L548-L639)

### 冲突解决器

冲突解决器提供了智能化的时间槽推荐功能：

```mermaid
classDiagram
class ConflictResolver {
-service Service
+Resolve(ctx, userID, start, end, duration) ConflictResolution
+FindAllFreeSlots(ctx, userID, date, duration) []TimeSlot
-findAlternatives(ctx, userID, requested, duration) []TimeSlot
-findSlotsInDay(ctx, userID, date, duration, hourStart, hourEnd) []TimeSlot
-findSlotsInRange(ctx, userID, startOfDay, endOfDay, duration, loc) []TimeSlot
-selectBestAlternative(requested, alternatives) TimeSlot
-scoreAlternatives(requested, alternatives) []TimeSlot
-calculateScore(requested, alt) int
}
class TimeSlot {
+Start time.Time
+End time.Time
+Reason string
+Score int
+IsOriginal bool
+IsAdjacent bool
}
class ConflictResolution {
+OriginalStart time.Time
+OriginalEnd time.Time
+Conflicts []*ScheduleInstance
+Alternatives []TimeSlot
+AutoResolved *TimeSlot
}
ConflictResolver --> TimeSlot
ConflictResolver --> ConflictResolution
```

**图表来源**
- [conflict_resolver.go](file://server/service/schedule/conflict_resolver.go#L15-L43)

#### 时间槽评分算法

冲突解决器使用综合评分系统来评估可用时间槽的质量：

| 评分因素 | 分值范围 | 说明 |
|----------|----------|------|
| 同一天 | 100分 | 最高优先级 |
| 相同时段 | 50分 | 上午/下午偏好 |
| 相同星期几 | 10分 | 连续性偏好 |
| 商务时间 | 15分 | 9-11点或14-16点 |
| 相邻日期 | -5分 | 距离惩罚 |
| 同一小时 | 取决于差异 | 越接近越好 |

**章节来源**
- [conflict_resolver.go](file://server/service/schedule/conflict_resolver.go#L264-L326)

### 重复规则处理

服务层支持简化的重复规则格式，基于自定义JSON格式而非完整的RFC 5545标准：

```mermaid
classDiagram
class RecurrenceRule {
+Type RecurrenceType
+Interval int
+Weekdays []int
+MonthDay int
+Validate() error
+GenerateInstances(startTs, endTs) []int64
+ToJSON() string
+ParseRecurrenceRuleFromJSON(jsonStr) *RecurrenceRule
}
class RecurrenceType {
<<enumeration>>
daily
weekly
monthly
}
class RecurrenceIterator {
-rule *RecurrenceRule
-startTs int64
-cache []int64
-cacheEndTs int64
-maxCache int
-exhausted bool
+Iterator(rule, startTs) *RecurrenceIterator
+GetUntil(endTs) []int64
+Next() int64
+CountInRange(startTs, endTs) int
}
RecurrenceRule --> RecurrenceType
RecurrenceRule --> RecurrenceIterator
```

**图表来源**
- [recurrence.go](file://plugin/ai/schedule/recurrence.go#L42-L47)
- [recurrence.go](file://plugin/ai/schedule/recurrence.go#L342-L363)

**章节来源**
- [recurrence.go](file://plugin/ai/schedule/recurrence.go#L42-L75)
- [recurrence.go](file://plugin/ai/schedule/recurrence.go#L151-L193)

## 依赖关系分析

### 组件耦合度

服务层采用了松耦合的设计原则，通过接口抽象实现了良好的模块隔离：

```mermaid
graph TB
subgraph "外部依赖"
A[PostgreSQL驱动]
B[SQLite驱动]
C[RRule解析器]
D[时区工具]
E[gRPC框架]
end
subgraph "内部组件"
F[ScheduleService]
G[ConflictResolver]
H[Store接口]
I[错误分类系统]
end
F --> H
F --> G
F --> C
G --> F
H --> A
H --> B
I --> F
E --> F
```

**图表来源**
- [service.go](file://server/service/schedule/service.go#L70-L81)
- [conflict_resolver.go](file://server/service/schedule/conflict_resolver.go#L15-L24)

### 错误处理策略

服务层实现了分级的错误处理机制：

```mermaid
flowchart TD
ErrorStart([发生错误]) --> CheckScheduleConflict{"是否为日程冲突?"}
CheckScheduleConflict --> |是| ReturnConflictError["返回冲突错误"]
CheckScheduleConflict --> |否| CheckDBConflict{"是否为数据库约束冲突?"}
CheckDBConflict --> |是| ReturnDBError["返回数据库错误"]
CheckDBConflict --> |否| CheckNetworkError{"是否为网络错误?"}
CheckNetworkError --> |是| ReturnTransientError["返回临时错误"]
CheckNetworkError --> |否| CheckTimeoutError{"是否为超时错误?"}
CheckTimeoutError --> |是| ReturnTimeoutError["返回超时错误"]
CheckTimeoutError --> |否| ReturnPermanentError["返回永久错误"]
ReturnConflictError --> ErrorEnd([错误处理完成])
ReturnDBError --> ErrorEnd
ReturnTransientError --> ErrorEnd
ReturnTimeoutError --> ErrorEnd
ReturnPermanentError --> ErrorEnd
```

**图表来源**
- [error_class.go](file://plugin/ai/agent/error_class.go#L92-L109)

**章节来源**
- [error_class.go](file://plugin/ai/agent/error_class.go#L17-L32)

## 性能考虑

### 查询优化

服务层采用了多种性能优化策略：

1. **索引优化**：使用按小时分桶的冲突索引，提高查询效率
2. **批量查询**：一次性查询所有可能冲突的日程，减少多次数据库往返
3. **实例限制**：设置最大实例数量限制，防止内存溢出
4. **缓存机制**：重复规则迭代器使用缓存避免重复计算

### 内存管理

```mermaid
flowchart TD
Start([开始处理]) --> CheckMemory["检查可用内存"]
CheckMemory --> HasMemory{"内存充足?"}
HasMemory --> |是| ProcessBatch["批量处理日程"]
HasMemory --> |否| ProcessSingle["单个处理模式"]
ProcessBatch --> CheckLimit{"达到实例限制?"}
CheckLimit --> |是| Truncate["截断并记录"]
CheckLimit --> |否| Continue["继续处理"]
ProcessSingle --> Continue
Continue --> MoreItems{"还有更多项目?"}
MoreItems --> |是| CheckMemory
MoreItems --> |否| Complete["处理完成"]
Truncate --> Complete
Complete --> End([结束])
```

**图表来源**
- [service.go](file://server/service/schedule/service.go#L111-L165)

### 并发处理

服务层支持并发操作，但需要注意以下限制：
- **读操作**：查询和冲突检测支持并发
- **写操作**：创建和更新操作通过数据库约束保证原子性
- **迭代器**：重复规则迭代器使用互斥锁保护线程安全

**章节来源**
- [service.go](file://server/service/schedule/service.go#L641-L684)
- [recurrence.go](file://plugin/ai/schedule/recurrence.go#L342-L363)

## 故障排除指南

### 常见问题诊断

#### 冲突检测失败

当遇到冲突检测问题时，可以按照以下步骤排查：

1. **检查时区设置**：确认日程的时区设置正确
2. **验证时间范围**：确保开始时间和结束时间参数有效
3. **检查重复规则**：验证重复规则的JSON格式正确
4. **查看数据库约束**：检查是否存在违反唯一性约束的情况

#### 实例展开异常

重复日程实例展开失败的常见原因：

1. **重复规则解析错误**：检查JSON格式是否符合预期
2. **时间戳转换问题**：确认UTC时间戳转换正确
3. **实例数量限制**：检查是否达到最大实例数量限制
4. **内存不足**：监控内存使用情况，必要时调整限制

### 调试技巧

```mermaid
flowchart TD
DebugStart([开始调试]) --> EnableLogging["启用详细日志"]
EnableLogging --> ReproduceIssue["重现问题"]
ReproduceIssue --> CheckLogs["检查日志输出"]
CheckLogs --> AnalyzeTrace["分析调用跟踪"]
AnalyzeTrace --> IdentifyRootCause["识别根本原因"]
IdentifyRootCause --> FixIssue["修复问题"]
FixIssue --> VerifyFix["验证修复效果"]
VerifyFix --> DebugComplete([调试完成])
CheckLogs --> CheckDatabase["检查数据库状态"]
CheckDatabase --> AnalyzeQuery["分析查询计划"]
AnalyzeQuery --> OptimizeQuery["优化查询"]
OptimizeQuery --> VerifyFix
```

**图表来源**
- [service.go](file://server/service/schedule/service.go#L196-L204)

**章节来源**
- [service_test.go](file://server/service/schedule/service_test.go#L1-L517)
- [conflict_resolver_test.go](file://server/service/schedule/conflict_resolver_test.go#L1-L444)

## 结论

日程服务层展现了优秀的软件工程实践，通过清晰的分层架构、完善的错误处理机制和高效的性能优化策略，为整个系统提供了可靠的日程管理能力。

### 主要优势

1. **架构清晰**：采用分层设计，职责分离明确
2. **功能完整**：覆盖日程管理的所有核心功能
3. **性能优秀**：通过多种优化策略确保高效运行
4. **扩展性强**：接口设计支持未来功能扩展
5. **可靠性高**：多重约束和错误处理确保数据一致性

### 改进建议

1. **事务管理**：可以考虑引入更细粒度的事务控制
2. **缓存策略**：可以增加更多类型的缓存以提升性能
3. **监控指标**：可以添加更多性能监控指标
4. **国际化支持**：可以增强多语言支持能力

该服务层为日程管理功能奠定了坚实的基础，为用户提供了流畅的日程体验，同时也为系统的进一步发展提供了良好的技术支撑。