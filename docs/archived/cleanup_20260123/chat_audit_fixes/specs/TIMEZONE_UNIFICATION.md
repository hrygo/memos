# 时区统一化设计规格

## 一、概述

**目标**: 统一聊天服务中的时区处理逻辑，确保用户看到的时间与实际数据一致。

**版本**: v1.0
**状态**: 设计中
**优先级**: P0 (紧急)

---

## 二、背景与问题

### 当前问题

1. **时区混乱**: QueryRouter 使用 UTC，数据库存储 Unix 时间戳（无时区），显示时使用本地时区
2. **跨日期边界**: UTC 时间与本地时间转换时可能跨越日期边界，导致查询结果不一致
3. **用户困惑**: 用户查询"今天"的日程，但实际查询的是 UTC 的"今天"

### 影响范围

- 所有时间相关的查询和显示
- 跨时区用户的使用体验
- 日程创建和检索的准确性

---

## 三、设计目标

1. **一致性**: 所有时间处理使用统一的时区策略
2. **可预测性**: 用户看到的时间与查询条件一致
3. **性能**: 时区转换不应显著影响性能
4. **兼容性**: 不破坏现有的数据和 API

---

## 四、技术方案

### 4.1 时区策略选择

**方案 A: 全程使用用户本地时区**

**优点**:
- 用户看到的时间与查询条件一致
- 直观，符合用户预期

**缺点**:
- 需要知道用户的时区（需要前端传递或用户配置）
- 服务端需要处理多个时区

**方案 B: 全程使用 UTC**

**优点**:
- 服务端逻辑统一
- 不需要用户时区信息

**缺点**:
- 用户看到的时间可能与预期不符
- 需要在显示层进行时区转换

**推荐方案**: **方案 A - 全程使用用户本地时区**

**理由**:
1. 用户体验优先
2. 避免查询结果与用户预期不一致
3. 时区转换成本可接受

---

### 4.2 架构设计

```
┌─────────────────────────────────────────────────────────────┐
│                        用户请求                               │
│  "今天有哪些日程？" (用户的本地时间，如 Asia/Shanghai)        │
└───────────────────────────┬─────────────────────────────────┘
                            │
                            ▼
┌─────────────────────────────────────────────────────────────┐
│                    前端 (Web/Mobile)                         │
│  传递用户时区:                                                 │
│  - timezone: "Asia/Shanghai" 或                              │
│  - timezoneOffset: +480 (UTC+8)                             │
└───────────────────────────┬─────────────────────────────────┘
                            │
                            ▼
┌─────────────────────────────────────────────────────────────┐
│              Connect Handler / gRPC Handler                  │
│  1. 接收用户时区                                              │
│  2. 创建带时区的 context                                      │
└───────────────────────────┬─────────────────────────────────┘
                            │
                            ▼
┌─────────────────────────────────────────────────────────────┐
│                    Query Router                              │
│  1. 使用用户时区解析时间范围                                   │
│  2. 例: "今天" → 2026-01-21 00:00:00+08 ~ 2026-01-22 00:00:00+08 │
└───────────────────────────┬─────────────────────────────────┘
                            │
                            ▼
┌─────────────────────────────────────────────────────────────┐
│                   Adaptive Retriever                         │
│  1. 将用户时区的时间转换为 Unix 时间戳（UTC）                 │
│  2. 查询数据库                                                │
└───────────────────────────┬─────────────────────────────────┘
                            │
                            ▼
┌─────────────────────────────────────────────────────────────┐
│                      数据库                                  │
│  存储: Unix 时间戳 (UTC)                                      │
│  查询: 基于 Unix 时间戳范围                                   │
└───────────────────────────┬─────────────────────────────────┘
                            │
                            ▼
┌─────────────────────────────────────────────────────────────┐
│                   Response Builder                           │
│  1. 将 Unix 时间戳转换回用户时区                              │
│  2. 格式化显示: "2026-01-21 14:00"                           │
└───────────────────────────┬─────────────────────────────────┘
                            │
                            ▼
┌─────────────────────────────────────────────────────────────┐
│                      前端显示                                │
│  "今天 14:00 - 团队周会"                                      │
└─────────────────────────────────────────────────────────────┘
```

---

### 4.3 数据流设计

#### 4.3.1 请求流

```
用户请求 → [用户时区] → QueryRouter → [时间范围] → AdaptiveRetriever → [Unix 时间戳] → 数据库
```

#### 4.3.2 响应流

```
数据库 → [Unix 时间戳] → AdaptiveRetriever → [Schedule 对象] → ResponseBuilder → [用户时区时间] → 前端
```

---

### 4.4 接口设计

#### 4.4.1 API 请求扩展

```protobuf
message ChatWithMemosRequest {
  string message = 1;
  repeated string history = 2;
  // 新增字段
  string user_timezone = 3;  // IANA 时区标识，如 "Asia/Shanghai"
}
```

#### 4.4.2 Context 设计

```go
type RequestContext struct {
    UserID    int32
    Timezone  *time.Location  // 用户时区
    // ... 其他字段
}
```

#### 4.4.3 时间范围计算

```go
// 在用户时区中计算时间范围
func (r *QueryRouter) CalculateTimeRange(keyword string, userTimezone *time.Location) *TimeRange {
    now := time.Now().In(userTimezone)
    // ... 基于用户时区计算
}

// 转换为 Unix 时间戳用于数据库查询
func (tr *TimeRange) ToUnixRange() (startTs, endTs int64) {
    return tr.Start.Unix(), tr.End.Unix()
}
```

---

### 4.5 工具函数设计

#### 4.5.1 时区解析

```go
// ParseTimezone 解析 IANA 时区标识
func ParseTimezone(tz string) (*time.Location, error)

// GetDefaultTimezone 获取默认时区（UTC）
func GetDefaultTimezone() *time.Location

// IsValidTimezone 验证时区标识是否有效
func IsValidTimezone(tz string) bool
```

#### 4.5.2 时间转换

```go
// ToUserTimezone 将 Unix 时间戳转换到用户时区
func ToUserTimezone(ts int64, tz *time.Location) time.Time

// FormatTimeWithTimezone 格式化时间显示
func FormatTimeWithTimezone(ts int64, tz *time.Location, format string) string

// FormatScheduleTime 格式化日程时间
func FormatScheduleTime(startTs int64, endTs *int64, tz *time.Location) string
```

#### 4.5.3 时间范围验证

```go
// ValidateTimeRangeInTimezone 在指定时区中验证时间范围
func ValidateTimeRangeInTimezone(tr *TimeRange, tz *time.Location) error

// IsTimeRangeInFuture 检查时间范围是否在未来
func IsTimeRangeInFuture(tr *TimeRange, tz *time.Location) bool
```

---

## 五、关键场景设计

### 5.1 场景 1: 用户查询今天的日程

**用户时区**: Asia/Shanghai (UTC+8)
**UTC 时间**: 2026-01-20 16:00:00
**用户本地时间**: 2026-01-21 00:00:00

**执行流程**:

1. 用户查询: "今天有哪些日程？"
2. QueryRouter 解析:
   - 用户时区: Asia/Shanghai
   - "今天" = 2026-01-21 00:00:00+08 ~ 2026-01-22 00:00:00+08
3. 转换为 Unix 时间戳:
   - startTs: 1737408000 (2026-01-21 00:00:00+08)
   - endTs: 1737494400 (2026-01-22 00:00:00+08)
4. 数据库查询: `WHERE start_ts >= 1737408000 AND end_ts <= 1737494400`
5. 结果格式化: "2026-01-21 14:00 - 团队周会"

### 5.2 场景 2: 跨时区用户查询

**用户时区**: America/New_York (UTC-5)
**UTC 时间**: 2026-01-21 02:00:00
**用户本地时间**: 2026-01-20 21:00:00

**执行流程**:

1. 用户查询: "今天有哪些日程？"
2. QueryRouter 解析:
   - 用户时区: America/New_York
   - "今天" = 2026-01-20 00:00:00-05 ~ 2026-01-21 00:00:00-05
3. 转换为 Unix 时间戳:
   - startTs: 1737331200 (2026-01-20 00:00:00-05)
   - endTs: 1737417600 (2026-01-21 00:00:00-05)
4. 数据库查询（同上）
5. 结果格式化: "Jan 20, 2026 9:00 PM - Team Meeting"

### 5.3 场景 3: 日程创建

**用户时区**: Asia/Shanghai (UTC+8)
**用户输入**: "明天下午3点开会"

**执行流程**:

1. 解析时间:
   - 用户时区: Asia/Shanghai
   - "明天下午3点" = 2026-01-22 15:00:00+08
2. 转换为 Unix 时间戳:
   - startTs: 1737524400
3. 存储: 数据库存储 Unix 时间戳
4. 显示时转换回用户时区

---

## 六、错误处理

### 6.1 时区缺失

**处理**: 使用默认时区 UTC

**日志**: `[WARN] User timezone not provided, using UTC`

### 6.2 时区无效

**处理**: 使用默认时区 UTC，返回警告

**日志**: `[WARN] Invalid timezone "%s", using UTC`

### 6.3 时区转换失败

**处理**: 返回原始 UTC 时间，添加错误信息

**日志**: `[ERROR] Failed to convert timezone: %v`

---

## 七、测试用例

### 7.1 单元测试

| 测试用例 | 描述 | 预期结果 |
|---------|------|----------|
| 时区解析有效 IANA | 传入 "Asia/Shanghai" | 返回对应 Location |
| 时区解析无效标识 | 传入 "Invalid/Timezone" | 返回错误 |
| 时间转换 UTC 到用户时区 | 传入 UTC 时间戳和时区 | 返回正确的本地时间 |
| 时间转换用户时区到 UTC | 传入本地时间和时区 | 返回正确的 UTC 时间戳 |
| 时间格式化 | 传入时间戳和时区 | 返回格式化的字符串 |
| "今天"解析 | 在 Asia/Shanghai 时区 | 返回今天的 00:00 ~ 24:00 |
| "明天"解析 | 在 America/New_York 时区 | 返回明天的 00:00 ~ 24:00 |

### 7.2 集成测试

| 测试用例 | 描述 | 预期结果 |
|---------|------|----------|
| 完整查询流程 | 用户查询今天的日程 | 返回正确时区的日程 |
| 跨时区查询 | 不同时区用户查询同一日期 | 返回各自时区的正确结果 |
| 日程创建流程 | 用户创建日程 | 存储正确的 UTC 时间戳 |
| 日程显示流程 | 显示存储的日程 | 显示用户时区的正确时间 |

### 7.3 边界测试

| 测试用例 | 描述 | 预期结果 |
|---------|------|----------|
| 日期边界 | 23:59:59 和 00:00:01 | 正确处理跨天 |
| 夏令时切换 | 美国时区夏令时开始/结束 | 正确处理时间变化 |
| 极端时区 | UTC+12 和 UTC-11 | 正确处理 |

---

## 八、性能考虑

### 8.1 时区解析缓存

**策略**: 缓存常用的时区 Location 对象

**实现**:
```go
var timezoneCache = sync.Map{}
func GetCachedTimezone(tz string) (*time.Location, error) {
    if loc, ok := timezoneCache.Load(tz); ok {
        return loc.(*time.Location), nil
    }
    loc, err := time.LoadLocation(tz)
    if err == nil {
        timezoneCache.Store(tz, loc)
    }
    return loc, err
}
```

### 8.2 时间转换优化

**优化**: 避免重复的时间转换

**实现**: 在 RequestContext 中缓存时区 Location

---

## 九、兼容性考虑

### 9.1 向后兼容

**现有 API**: 不传递时区时使用 UTC

**新 API**: 推荐传递时区

### 9.2 数据兼容

**数据库**: 不变更，继续使用 Unix 时间戳

**API 响应**: 返回 UTC 时间戳，前端负责转换

---

## 十、实施计划

### 10.1 开发阶段

1. **Day 1-2**: 实现时区工具函数
2. **Day 3-4**: 更新 QueryRouter 支持用户时区
3. **Day 5**: 更新 AdaptiveRetriever
4. **Day 6**: 更新 Response Builder
5. **Day 7**: 编写测试和验证

### 10.2 测试阶段

1. **Day 8**: 单元测试
2. **Day 9**: 集成测试
3. **Day 10**: 边界测试和性能测试

### 10.3 部署阶段

1. **Day 11**: 灰度发布 (10%)
2. **Day 12**: 灰度发布 (50%)
3. **Day 13**: 全量发布

---

## 十一、验收标准

### 11.1 功能验收

- [ ] 所有时间计算使用用户时区
- [ ] 时间显示与用户查询一致
- [ ] 跨时区用户查询结果正确
- [ ] 日程创建和显示时间一致

### 11.2 性能验收

- [ ] 时区转换不影响响应时间（< 5% 增加）
- [ ] 时区缓存命中率 > 90%

### 11.3 兼容性验收

- [ ] 不传递时区时使用 UTC（向后兼容）
- [ ] 现有功能不受影响
- [ ] 所有现有测试通过

### 11.4 测试验收

- [ ] 单元测试覆盖率 ≥ 90%
- [ ] 所有测试用例通过
- [ ] 零 P0/P1 bug

---

## 十二、风险与缓解

| 风险 | 缓解措施 |
|------|----------|
| 前端未传递时区 | 默认使用 UTC，添加警告日志 |
| 时区标识无效 | 验证时区，使用默认值 |
| 性能退化 | 使用时区缓存，避免重复转换 |
| 用户时区与服务器时区不一致 | 明确文档，全程使用用户时区 |

---

## 十三、相关文档

- [实施方案](../IMPLEMENTATION_PLAN.md)
- [Chat 服务统一化](./CHAT_SERVICE_UNIFICATION.md)
- [日程查询优化](./SCHEDULE_QUERY_OPTIMIZATION.md)
