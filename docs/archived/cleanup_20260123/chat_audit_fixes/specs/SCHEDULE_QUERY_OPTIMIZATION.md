# 日程查询优化设计规格

## 一、概述

**目标**: 优化日程查询的时间过滤逻辑和年份推断功能，提高查询准确性和用户体验。

**版本**: v1.0
**状态**: 设计中
**优先级**: P1 (重要)

---

## 二、背景与问题

### 当前问题

#### 问题 1: 时间过滤逻辑宽松

**当前实现** (`store/db/postgres/schedule.go:69-80`):
```sql
WHERE (schedule.end_ts >= ? OR schedule.end_ts IS NULL)
  AND schedule.start_ts <= ?
```

**问题**:
- 查询"今天"（2026-01-21 00:00 ~ 2026-01-22 00:00）
- 会返回昨天 23:00 开始的跨天日程
- 会返回明天 00:00 开始的日程（因为 start_ts <= 结束时间）

#### 问题 2: 年份推断单一

**当前实现** (`server/queryengine/query_router.go:544-552`):
- 只能推断当年或明年
- 无法明确指定年份
- 无法表达"后年"、"大后年"等

### 影响范围

- 跨天日程的查询结果
- 未来年份的日程查询
- 用户对查询结果的预期

---

## 三、设计目标

1. **精确性**: 查询结果与用户预期一致
2. **灵活性**: 支持多种时间表达方式
3. **可控性**: 提供可选的严格模式
4. **向后兼容**: 不破坏现有功能

---

## 四、技术方案

### 4.1 时间过滤优化

#### 4.1.1 两种查询模式

**模式 1: 标准模式（默认）**

语义: 返回在查询时间范围内**有任何部分**的日程

适用场景: 大多数查询场景，用户希望看到相关的所有日程

SQL:
```sql
WHERE (schedule.end_ts >= ? OR schedule.end_ts IS NULL)
  AND schedule.start_ts <= ?
```

**模式 2: 严格模式**

语义: 只返回**完全在**查询时间范围内的日程

适用场景: 用户明确指定时间范围，希望精确匹配

SQL:
```sql
WHERE schedule.start_ts >= ?
  AND (schedule.end_ts <= ? OR schedule.end_ts IS NULL)
```

#### 4.1.2 模式选择策略

**自动选择规则**:
1. **相对时间查询**（今天、明天、本周）→ 使用标准模式
   - 理由: 用户可能想知道今天相关的所有事项
2. **绝对时间查询**（1月21日、2025年3月15日）→ 使用严格模式
   - 理由: 用户明确指定了具体日期，希望精确匹配
3. **用户明确指定**（API 参数）→ 优先使用用户选择

#### 4.1.3 API 扩展

```protobuf
message ChatWithMemosRequest {
  string message = 1;
  repeated string history = 2;
  string user_timezone = 3;

  // 新增字段
  ScheduleQueryMode schedule_query_mode = 4;  // 查询模式
}

enum ScheduleQueryMode {
  STANDARD = 0;   // 标准模式（默认）
  STRICT = 1;     // 严格模式
}
```

---

### 4.2 年份推断优化

#### 4.2.1 支持的时间表达

**相对年份表达**:
| 表达 | 含义 | 示例 |
|------|------|------|
| 今年 | 当前年份 | "今年的日程" |
| 明年 | 当前年份 + 1 | "明年的计划" |
| 后年 | 当前年份 + 2 | "后年的项目" |
| 大后年 | 当前年份 + 3 | "大后年的目标" |
| 去年 | 当前年份 - 1 | "去年的总结" |
| 前年 | 当前年份 - 2 | "前年的数据" |

**绝对年份表达**:
| 格式 | 示例 | 支持 |
|------|------|------|
| YYYY年MM月DD日 | 2025年1月21日 | ✅ 新增 |
| YYYY-MM-DD | 2025-01-21 | ✅ 新增 |
| YYYY/MM/DD | 2025/01/21 | ✅ 新增 |
| MM月DD日 | 1月21日 | ✅ 已有 |

#### 4.2.2 年份推断算法

```go
// 推断规则（按优先级）:
// 1. 明确指定年份 → 使用指定年份
// 2. 相对年份表达 → 计算相对年份
// 3. 纯日期表达（MM月DD日）→ 启发式推断
//    a. 日期在未来（含今天）→ 当年
//    b. 日期在过去且在最近3个月 → 明年（循环计划）
//    c. 日期在过去且超过3个月 → 明年（或提示用户）
```

#### 4.2.3 启发式推断示例

**场景 1: 查询未来日期**
- 当前日期: 2026-01-21
- 查询: "3月15日"
- 推断: 2026-03-15（今年）
- 理由: 3月15日在未来

**场景 2: 查询最近的过去日期**
- 当前日期: 2026-01-21
- 查询: "1月1日"
- 推断: 2027-01-01（明年）
- 理由: 1月1日刚过去，可能是查询明年的

**场景 3: 查询遥远的过去日期**
- 当前日期: 2026-01-21
- 查询: "6月1日"
- 推断: 2026-06-01（今年）
- 理由: 6月1日在未来

**场景 4: 明确指定年份**
- 查询: "2025年12月25日"
- 推断: 2025-12-25
- 理由: 用户明确指定

---

### 4.3 时间范围计算优化

#### 4.3.1 时间范围计算接口

```go
// TimeRangeCalculator 时间范围计算器
type TimeRangeCalculator interface {
    // CalculateTimeRange 计算时间范围
    // 返回: 开始时间、结束时间、标签、是否严格模式
    CalculateTimeRange(query string, baseTime time.Time, tz *time.Location) (*TimeRangeSpec, error)
}

// TimeRangeSpec 时间范围规格
type TimeRangeSpec struct {
    StartTime    time.Time
    EndTime      time.Time
    Label        string
    StrictMode   bool    // 是否使用严格模式
    Confidence   float32 // 推断置信度
}
```

#### 4.3.2 关键词映射扩展

**新增年份关键词**:
```go
yearKeywords := map[string]func(base time.Time) int{
    "今年":  func(t time.Time) int { return t.Year() },
    "明年":  func(t time.Time) int { return t.Year() + 1 },
    "后年":  func(t time.Time) int { return t.Year() + 2 },
    "大后年": func(t time.Time) int { return t.Year() + 3 },
    "去年":  func(t time.Time) int { return t.Year() - 1 },
    "前年":  func(t time.Time) int { return t.Year() - 2 },
}
```

**新增日期格式支持**:
```go
dateFormats := []struct{
    pattern *regexp.Regexp
    handler func(matches []string, base time.Time) (time.Time, time.Time, error)
}{
    // YYYY年MM月DD日
    {regexp.MustCompile(`(\d{4})年(\d{1,2})月(\d{1,2})日`), handleFullYearFormat},
    // YYYY-MM-DD
    {regexp.MustCompile(`(\d{4})-(\d{1,2})-(\d{1,2})`), handleDashFullYearFormat},
    // YYYY/MM/DD
    {regexp.MustCompile(`(\d{4})/(\d{1,2})/(\d{1,2})`), handleSlashFullYearFormat},
    // ... 其他格式
}
```

---

## 五、关键场景设计

### 5.1 场景 1: 查询今天的日程（标准模式）

**用户查询**: "今天有哪些日程？"

**执行流程**:

1. QueryRouter 解析:
   - 时间范围: 今天 00:00 ~ 明天 00:00
   - 查询模式: STANDARD（标准）
   - 用户时区: Asia/Shanghai

2. 转换为 Unix 时间戳:
   - startTs: 1737408000
   - endTs: 1737494400

3. 数据库查询（标准模式）:
   ```sql
   WHERE (end_ts >= 1737408000 OR end_ts IS NULL)
     AND start_ts <= 1737494400
   ```

4. 返回结果:
   - 今天 14:00 - 16:00 的会议 ✅
   - 昨天 23:00 - 今天 01:00 的跨天日程 ✅（标准模式）
   - 明天 00:00 - 02:00 的日程 ✅（标准模式）

### 5.2 场景 2: 查询特定日期（严格模式）

**用户查询**: "1月21日有什么安排？"

**执行流程**:

1. QueryRouter 解析:
   - 时间范围: 2026-01-21 00:00 ~ 2026-01-22 00:00
   - 查询模式: STRICT（严格）← 绝对日期自动选择
   - 用户时区: Asia/Shanghai

2. 数据库查询（严格模式）:
   ```sql
   WHERE start_ts >= 1737408000
     AND (end_ts <= 1737494400 OR end_ts IS NULL)
   ```

3. 返回结果:
   - 今天 14:00 - 16:00 的会议 ✅
   - 昨天 23:00 - 今天 01:00 的日程 ❌（不完全在今天）
   - 明天 00:00 - 02:00 的日程 ❌（不完全在今天）

### 5.3 场景 3: 查询明年的日程

**用户查询**: "明年的1月21日"

**执行流程**:

1. QueryRouter 解析:
   - 年份: 当前年份 + 1
   - 日期: 1月21日
   - 时间范围: 2027-01-21 00:00 ~ 2027-01-22 00:00
   - 查询模式: STRICT

2. 数据库查询:
   - 返回 2027 年 1 月 21 日的日程

### 5.4 场景 4: 明确指定年份

**用户查询**: "2025年12月25日"

**执行流程**:

1. QueryRouter 解析:
   - 年份: 2025（明确指定）
   - 日期: 12月25日
   - 时间范围: 2025-12-25 00:00 ~ 2025-12-26 00:00
   - 查询模式: STRICT
   - 置信度: 1.0（高置信度）

2. 数据库查询:
   - 返回 2025 年 12 月 25 日的日程

---

## 六、测试用例

### 6.1 时间过滤测试

| 测试用例 | 查询 | 模式 | 预期结果 |
|---------|------|------|----------|
| 标准模式 - 今天 | "今天" | STANDARD | 包含跨天日程 |
| 严格模式 - 今天 | "今天" | STRICT | 不包含跨天日程 |
| 标准模式 - 具体日期 | "1月21日" | STANDARD | 包含跨天日程 |
| 严格模式 - 具体日期 | "1月21日" | STRICT | 不包含跨天日程 |
| 全天日程 | "今天" | STRICT | 包含全天日程 |

### 6.2 年份推断测试

| 测试用例 | 查询 | 当前日期 | 预期推断 |
|---------|------|----------|----------|
| 未来日期 | "3月15日" | 2026-01-21 | 2026-03-15 |
| 最近过去 | "1月1日" | 2026-01-21 | 2027-01-01 |
| 遥远过去 | "6月1日" | 2026-01-21 | 2026-06-01 |
| 明确今年 | "今年1月21日" | 2026-01-21 | 2026-01-21 |
| 明确明年 | "明年1月21日" | 2026-01-21 | 2027-01-21 |
| 明确后年 | "后年1月21日" | 2026-01-21 | 2028-01-21 |
| 明确去年 | "去年1月21日" | 2026-01-21 | 2025-01-21 |
| 四位年份 | "2025年1月21日" | 2026-01-21 | 2025-01-21 |
| 短横线格式 | "2025-01-21" | 2026-01-21 | 2025-01-21 |
| 短斜杠格式 | "2025/01/21" | 2026-01-21 | 2025-01-21 |

### 6.3 边界测试

| 测试用例 | 描述 | 预期结果 |
|---------|------|----------|
| 闰年2月29日 | "2024年2月29日" | 正确解析（闰年） |
| 非闰年2月29日 | "2025年2月29日" | 返回错误 |
| 无效日期 | "2月30日" | 返回错误 |
| 无效月份 | "13月1日" | 返回错误 |
| 日期边界 | "12月31日" 查询 "1月1日" | 推断为明年 |

---

## 七、实施计划

### 7.1 阶段 1: 时间过滤优化

1. 修改 `FindSchedule` 结构，添加 `StrictMode` 字段
2. 更新数据库查询逻辑，支持两种模式
3. 更新 AdaptiveRetriever，传递模式参数
4. 编写测试

### 7.2 阶段 2: 年份推断优化

1. 扩展时间关键词映射
2. 添加新日期格式的正则表达式
3. 实现启发式推断算法
4. 编写测试

### 7.3 阶段 3: 集成和验证

1. 集成两个优化
2. E2E 测试
3. 性能测试
4. 用户验收测试

---

## 八、验收标准

### 8.1 功能验收

- [ ] 支持标准和严格两种查询模式
- [ ] 支持明确的年份表达
- [ ] 支持相对年份表达（今年、明年、后年等）
- [ ] 支持新的日期格式（YYYY-MM-DD、YYYY/MM/DD）
- [ ] 年份推断准确率 ≥ 95%

### 8.2 性能验收

- [ ] 查询响应时间不受影响（< 5% 增加）
- [ ] 日期解析时间 < 10ms

### 8.3 测试验收

- [ ] 单元测试覆盖率 ≥ 85%
- [ ] 所有测试用例通过
- [ ] 零 P0/P1 bug

---

## 九、风险与缓解

| 风险 | 缓解措施 |
|------|----------|
| 严格模式导致结果为空 | 提示用户使用标准模式 |
| 年份推断错误 | 显示推断的年份，允许用户纠正 |
| 新格式不被识别 | 保持现有格式支持，逐步扩展 |
| 性能退化 | 优化正则表达式，缓存解析结果 |

---

## 十、相关文档

- [实施方案](../IMPLEMENTATION_PLAN.md)
- [Chat 服务统一化](./CHAT_SERVICE_UNIFICATION.md)
- [时区统一化](./TIMEZONE_UNIFICATION.md)
