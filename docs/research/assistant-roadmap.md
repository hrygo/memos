# Memos 私人智能助理升级路线图

> 基于"私人助理、私人部署"产品定位，结合 AI Agent 最佳实践，制定务实的升级路径。

**文档导航**: [主路线图](./00-master-roadmap.md) | [调研报告](./assistant-research.md) | [行业参考](./assistant-roadmap-industry.md)

---

## 目录

1. [产品定位分析](#1-产品定位分析)
2. [升级策略总览](#2-升级策略总览)
3. [分阶段实施方案](#3-分阶段实施方案)
4. [关键技术方案](#4-关键技术方案)
5. [ROI 分析](#5-roi-分析)
6. [风险与缓解](#6-风险与缓解)

---

## 1. 产品定位分析

### 1.1 产品定位约束

| 特性 | 含义 | 技术影响 |
|------|------|---------|
| **私人助理** | 单用户场景 | 无需多租户，可深度个性化 |
| **私人部署** | 本地/边缘运行 | 资源受限，需轻量化 |
| **非 SaaS** | 不对外提供服务 | 无需横向扩展、高并发 |

### 1.2 定位带来的机会

```
┌─────────────────────────────────────────────────────────────────┐
│                    私人助理独特优势                               │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ┌─────────────────┐                                            │
│  │   深度个性化    │  单用户 = 全量数据可用于个性化学习          │
│  └────────┬────────┘                                            │
│           │                                                     │
│  ┌────────▼────────┐                                            │
│  │   完全隐私      │  数据不离开本地，用户完全掌控               │
│  └────────┬────────┘                                            │
│           │                                                     │
│  ┌────────▼────────┐                                            │
│  │   简化架构      │  无需分布式、多租户、复杂权限               │
│  └────────┬────────┘                                            │
│           │                                                     │
│  ┌────────▼────────┐                                            │
│  │   快速迭代      │  单用户反馈闭环，快速验证                   │
│  └─────────────────┘                                            │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 1.3 与通用路线图的差异

| 维度 | 通用 Agent 路线 | 私人助理路线 | 原因 |
|------|----------------|-------------|------|
| **编排** | Multi-Agent + Handoffs | 保持 ChatRouter + 4 Agent | 复杂度/收益比不划算 |
| **记忆** | 三层企业级架构 | 轻量两层架构 | 单用户无需复杂隔离 |
| **Guardrails** | 多层防护框架 | 基础安全检查 | 私人场景风险低 |
| **评估** | 完整 Evals 体系 | 轻量指标采集 | 快速迭代即可 |
| **个性化** | 可选特性 | **核心特性** | 私人助理核心价值 |
| **资源** | 可横向扩展 | **必须轻量化** | 边缘部署约束 |

---

## 2. 升级策略总览

### 2.1 核心原则

```
┌─────────────────────────────────────────────────────────────────┐
│                       升级核心原则                               │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  1. 轻量优先                                                     │
│     └─ 每个特性必须评估资源开销，拒绝过度工程                    │
│                                                                 │
│  2. 个性化驱动                                                   │
│     └─ "懂你"是私人助理的核心竞争力                              │
│                                                                 │
│  3. 渐进增强                                                     │
│     └─ 先解决痛点，再锦上添花                                    │
│                                                                 │
│  4. 离线友好                                                     │
│     └─ 减少对云服务的强依赖                                      │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 2.2 三阶段路线图

```
┌─────────────────────────────────────────────────────────────────────────┐
│                         私人助理升级路线图                                │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  Phase 1: 稳定增强        Phase 2: 智能进化        Phase 3: 极致体验    │
│  ─────────────────       ─────────────────        ─────────────────    │
│  (夯实基础)               (提升智能)               (差异化竞争力)        │
│                                                                         │
│  • 轻量记忆系统           • 用户习惯学习           • 本地模型支持         │
│  • 基础评估指标           • Self-RAG 检索优化      • 预测性交互           │
│  • 路由准确性提升         • 上下文增强             • 语音交互             │
│  • 工具可靠性增强         • Generative UI 完善     • 主动提醒             │
│                                                                         │
│  ─────────────►          ─────────────►          ─────────────►        │
│   P0 (核心痛点)            P1 (智能升级)            P2 (体验差异化)       │
│                                                                         │
│  ROI: ★★★★★              ROI: ★★★★☆              ROI: ★★★☆☆            │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

---

## 3. 分阶段实施方案

### 3.1 Phase 1: 稳定增强 (P0)

**目标**: 解决当前痛点，建立可靠基础

#### 3.1.1 轻量记忆系统

**现状问题**:
- 仅支持会话内上下文，跨会话无记忆
- 用户偏好无法持久化
- 重复询问相同问题

**解决方案**:

```
┌─────────────────────────────────────────────────────────────────┐
│                    轻量两层记忆架构                               │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ┌───────────────────────────────────────────────────────────┐ │
│  │                   短期记忆 (会话内)                         │ │
│  │  • 滑动窗口上下文 (最近 10 轮)                              │ │
│  │  • 实现: 内存数组                                          │ │
│  │  • 开销: ~10KB/会话                                        │ │
│  └───────────────────────────────────────────────────────────┘ │
│                            │                                    │
│                            ▼                                    │
│  ┌───────────────────────────────────────────────────────────┐ │
│  │                   长期记忆 (跨会话)                         │ │
│  │                                                            │ │
│  │  ┌─────────────────────┐  ┌─────────────────────────────┐ │ │
│  │  │  情景记忆 (Episodic) │  │  用户偏好 (Preferences)     │ │ │
│  │  │  • 重要对话摘要      │  │  • 时区/语言                 │ │ │
│  │  │  • 任务执行历史      │  │  • 默认日程时长              │ │ │
│  │  │  • 常见问题模式      │  │  • 常用关键词                │ │ │
│  │  │  实现: SQLite 表     │  │  实现: JSON 配置             │ │ │
│  │  └─────────────────────┘  └─────────────────────────────┘ │ │
│  │                                                            │ │
│  │  存储开销: ~1MB (10万条记录)                               │ │
│  └───────────────────────────────────────────────────────────┘ │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

**数据模型**:

```go
// 情景记忆表
CREATE TABLE episodic_memory (
    id          INTEGER PRIMARY KEY,
    timestamp   DATETIME,
    user_input  TEXT,
    agent_type  TEXT,         -- memo/schedule/amazing
    outcome     TEXT,         -- success/failure
    summary     TEXT,         -- LLM 生成的摘要
    importance  REAL          -- 重要性评分 0-1
);

// 用户偏好 (JSON)
{
    "timezone": "Asia/Shanghai",
    "default_duration": 60,
    "preferred_times": ["09:00", "14:00"],
    "frequent_locations": ["会议室A", "办公室"],
    "communication_style": "concise"
}
```

**ROI 分析**:

| 投入 | 产出 |
|------|------|
| 开发: ~3 人天 | 跨会话记忆能力 |
| 存储: ~1MB | 减少重复询问 50%+ |
| 运行时: +5MB 内存 | 用户体验显著提升 |

---

#### 3.1.2 基础评估指标

**现状问题**:
- 无法量化 Agent 表现
- 问题难以定位
- 优化无据可依

**解决方案**:

```go
// 轻量指标采集 (嵌入式，无外部依赖)
type AgentMetrics struct {
    // 核心指标
    RequestCount     int64         // 请求总数
    SuccessCount     int64         // 成功数
    LatencyP50       time.Duration // P50 延迟
    LatencyP95       time.Duration // P95 延迟
    
    // 分 Agent 统计
    AgentStats       map[string]*AgentStat
    
    // 错误分类
    ErrorsByType     map[string]int64
}

// 持久化: 每小时写入 SQLite，保留 30 天
```

**指标展示** (管理后台简单页面):

```
┌────────────────────────────────────────────┐
│           AI 助理运行状态                   │
├────────────────────────────────────────────┤
│                                            │
│  今日请求: 47       成功率: 94%            │
│  平均延迟: 1.2s     P95: 2.8s              │
│                                            │
│  Agent 分布:                               │
│  ├─ 灰灰 (笔记): 28 次 ████████████        │
│  ├─ 金刚 (日程): 15 次 ██████              │
│  └─ 惊奇 (综合): 4 次  ██                  │
│                                            │
│  常见错误:                                 │
│  └─ LLM 超时: 2 次                         │
│                                            │
└────────────────────────────────────────────┘
```

**ROI 分析**:

| 投入 | 产出 |
|------|------|
| 开发: ~2 人天 | 问题可定位 |
| 存储: ~10MB/月 | 优化有据可依 |
| CPU: 可忽略 | 用户信任度提升 |

---

#### 3.1.3 路由准确性提升

**现状问题**:
- 规则匹配覆盖不全
- 边界 case 路由错误
- LLM 分类延迟高

**解决方案**:

```
┌─────────────────────────────────────────────────────────────────┐
│                    增强路由策略                                   │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  用户输入                                                        │
│      │                                                          │
│      ▼                                                          │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  Layer 1: 精确匹配 (0ms)                                 │   │
│  │  • 扩展关键词库 (从历史数据学习)                          │   │
│  │  • 正则模式匹配 (时间表达式等)                            │   │
│  └────────────────────────┬────────────────────────────────┘   │
│                           │ 未匹配                              │
│                           ▼                                     │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  Layer 2: 历史模式匹配 (~10ms)                           │   │
│  │  • 相似历史查询 → 复用路由决策                            │   │
│  │  • 基于情景记忆的快速匹配                                 │   │
│  └────────────────────────┬────────────────────────────────┘   │
│                           │ 未匹配                              │
│                           ▼                                     │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  Layer 3: LLM 分类 (~400ms)                              │   │
│  │  • 仅对真正模糊的输入使用                                 │   │
│  │  • 结果写入历史模式库                                     │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  目标: 80% 请求在 Layer 1/2 完成，LLM 调用降低 60%             │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

**ROI 分析**:

| 投入 | 产出 |
|------|------|
| 开发: ~3 人天 | LLM 调用减少 60% |
| 运行时: +2MB 内存 | 路由延迟 P50 < 50ms |
| | Token 成本降低 |

---

#### 3.1.4 工具可靠性增强

**现状问题**:
- 工具调用失败直接报错
- 无重试机制
- 错误信息不友好

**解决方案**:

```go
// 工具执行包装器
type ResilientToolExecutor struct {
    maxRetries     int           // 最大重试: 2
    retryDelay     time.Duration // 重试间隔: 500ms
    timeout        time.Duration // 单次超时: 10s
    fallbackAction FallbackFunc  // 降级动作
}

// 执行流程
func (e *ResilientToolExecutor) Execute(ctx context.Context, tool Tool, input string) (*Result, error) {
    for attempt := 0; attempt <= e.maxRetries; attempt++ {
        result, err := e.executeWithTimeout(ctx, tool, input)
        if err == nil {
            return result, nil
        }
        
        if !isRetryable(err) {
            break
        }
        
        time.Sleep(e.retryDelay)
    }
    
    // 降级处理
    return e.fallbackAction(ctx, tool, input)
}
```

**降级策略**:

| 工具 | 降级方案 |
|------|---------|
| memo_search | 返回 "搜索暂时不可用，请稍后重试" |
| schedule_query | 使用缓存数据（如有）|
| schedule_add | 转为"待确认"状态，提示用户手动确认 |

---

### 3.2 Phase 2: 智能进化 (P1)

**目标**: 提升智能程度，"越用越懂你"

#### 3.2.1 用户习惯学习

**核心能力**: 从历史交互中学习用户习惯

```
┌─────────────────────────────────────────────────────────────────┐
│                    用户习惯学习系统                               │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │                   习惯挖掘引擎                           │   │
│  │                                                          │   │
│  │  历史数据 ──► 模式识别 ──► 习惯提取 ──► 偏好更新         │   │
│  │                                                          │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  可学习的习惯:                                                  │
│                                                                 │
│  ┌─────────────────┐  ┌─────────────────┐  ┌─────────────────┐ │
│  │   时间习惯       │  │   日程习惯       │  │   搜索习惯      │ │
│  │                 │  │                 │  │                 │ │
│  │  • 活跃时段     │  │  • 常见时长     │  │  • 常用关键词   │ │
│  │  • 提醒提前量   │  │  • 偏好时间段   │  │  • 搜索模式     │ │
│  │  • 工作日模式   │  │  • 常用地点     │  │  • 结果偏好     │ │
│  └─────────────────┘  └─────────────────┘  └─────────────────┘ │
│                                                                 │
│  应用场景:                                                      │
│  • "开会" → 自动推断时长 1 小时（历史平均）                      │
│  • "明天下午" → 自动推荐 14:00（用户偏好）                       │
│  • 搜索结果 → 优先展示用户常访问的笔记类型                       │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

**实现方案**:

```go
// 习惯学习器
type HabitLearner struct {
    memory     *EpisodicMemory
    analyzer   *PatternAnalyzer
    predictor  *HabitPredictor
}

// 每日后台任务: 分析历史，更新习惯
func (h *HabitLearner) DailyAnalysis(ctx context.Context) error {
    // 1. 获取最近 30 天的成功交互
    episodes := h.memory.GetRecentSuccessful(30 * 24 * time.Hour)
    
    // 2. 提取模式
    patterns := h.analyzer.ExtractPatterns(episodes)
    
    // 3. 更新用户偏好
    for _, pattern := range patterns {
        h.updatePreference(pattern)
    }
    
    return nil
}

// 习惯预测
type HabitPredictor struct {
    preferences *UserPreferences
}

func (p *HabitPredictor) SuggestDuration(title string) time.Duration {
    // 基于历史相似日程的平均时长
    return p.preferences.GetAverageDuration(title)
}

func (p *HabitPredictor) SuggestTime(date time.Time) []time.Time {
    // 基于用户偏好时段
    return p.preferences.GetPreferredSlots(date)
}
```

**ROI 分析**:

| 投入 | 产出 |
|------|------|
| 开发: ~5 人天 | 用户操作减少 30% |
| 存储: ~5MB | "懂我"体验 |
| CPU: 每日 1 次后台分析 | 转化为产品差异化竞争力 |

---

#### 3.2.2 Self-RAG 检索优化

**现状问题**:
- 总是执行检索，即使不需要
- 检索质量不稳定
- 无自我评估机制

**轻量版 Self-RAG**:

```
┌─────────────────────────────────────────────────────────────────┐
│                    轻量 Self-RAG                                 │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  Query ──► [需要检索?] ──Yes──► Retrieve ──► [结果有用?]        │
│                │                                  │             │
│               No                                 Yes            │
│                │                                  │             │
│                ▼                                  ▼             │
│         Direct Answer                      Grounded Answer      │
│                                                   │             │
│                                                  No             │
│                                                   │             │
│                                                   ▼             │
│                                              Retry/Expand       │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘

实现方式 (非 LLM 判断):
- 需要检索? → 基于关键词/模式规则判断
- 结果有用? → 基于相关性分数阈值判断
```

```go
// 轻量检索决策器 (规则驱动，非 LLM)
func (s *SimpleSelfRAG) ShouldRetrieve(query string) bool {
    // 1. 闲聊类不检索
    if s.isChatQuery(query) {
        return false
    }
    
    // 2. 系统命令类不检索
    if s.isSystemCommand(query) {
        return false
    }
    
    // 3. 包含检索意图关键词
    if s.hasRetrievalIntent(query) {
        return true
    }
    
    // 4. 默认: 检索
    return true
}

// 结果评估 (基于分数阈值)
func (s *SimpleSelfRAG) IsResultUseful(results []*SearchResult) bool {
    if len(results) == 0 {
        return false
    }
    
    // Top1 分数 > 0.6 视为有用
    return results[0].Score > 0.6
}
```

**ROI 分析**:

| 投入 | 产出 |
|------|------|
| 开发: ~3 人天 | 无效检索减少 40% |
| 运行时: 可忽略 | 响应速度提升 |
| | 答案质量提升 |

---

#### 3.2.3 上下文增强

**目标**: 更智能的上下文利用

```go
// 增强上下文构建器
type EnhancedContextBuilder struct {
    shortTermMemory  *ShortTermMemory
    episodicMemory   *EpisodicMemory
    userPreferences  *UserPreferences
}

func (b *EnhancedContextBuilder) Build(ctx context.Context, query string) *Context {
    return &Context{
        // 当前会话上下文
        RecentMessages: b.shortTermMemory.GetRecent(5),
        
        // 相关历史 (语义检索)
        RelevantHistory: b.episodicMemory.SearchSimilar(query, 3),
        
        // 用户偏好
        UserPreferences: b.userPreferences.GetRelevant(query),
        
        // 时间上下文
        CurrentTime: time.Now(),
        Timezone:    b.userPreferences.Timezone,
    }
}
```

---

#### 3.2.4 Generative UI 完善

**新增组件**:

| 组件 | 功能 | 触发场景 |
|------|------|---------|
| `MemoPreview` | 笔记预览卡片 | memo_search 返回结果 |
| `QuickActions` | 快捷操作按钮 | 基于上下文推荐 |
| `ProgressTracker` | 多步骤进度 | 复杂任务执行 |

```typescript
// MemoPreview 组件
interface MemoPreviewProps {
  memo: {
    id: string;
    content: string;       // 截断预览
    highlights: string[];  // 高亮关键词
    createdAt: string;
  };
  onExpand: () => void;
  onInsert: () => void;    // 插入到当前编辑
}

// QuickActions 组件 (基于上下文的快捷操作)
// 例如: 查询日程后显示 "添加日程" | "查找空闲" 快捷按钮
```

---

### 3.3 Phase 3: 极致体验 (P2)

**目标**: 差异化竞争力，真正的"私人助理"

#### 3.3.1 本地模型支持

**动机**: 减少对云 API 依赖，降低延迟和成本

```
┌─────────────────────────────────────────────────────────────────┐
│                    混合模型架构                                   │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │                    请求分流器                            │   │
│  └────────────────────────┬────────────────────────────────┘   │
│                           │                                     │
│           ┌───────────────┼───────────────┐                     │
│           ▼               ▼               ▼                     │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────────────────┐ │
│  │ 本地小模型   │  │ 本地中模型   │  │      云端大模型         │ │
│  │ (1-3B)      │  │ (7B)        │  │  (GPT-4/Claude)        │ │
│  │             │  │             │  │                         │ │
│  │ 适用:       │  │ 适用:       │  │ 适用:                   │ │
│  │ • 意图分类  │  │ • 简单问答  │  │ • 复杂推理              │ │
│  │ • 实体提取  │  │ • 日程创建  │  │ • 长文总结              │ │
│  │ • 快速响应  │  │ • 笔记搜索  │  │ • 创意生成              │ │
│  │             │  │             │  │                         │ │
│  │ 延迟: <100ms│  │ 延迟: <500ms│  │ 延迟: 1-3s              │ │
│  │ 成本: $0    │  │ 成本: $0    │  │ 成本: ~$0.01/请求       │ │
│  └─────────────┘  └─────────────┘  └─────────────────────────┘ │
│                                                                 │
│  资源需求:                                                      │
│  • 小模型: ~2GB RAM                                             │
│  • 中模型: ~8GB RAM (可选)                                      │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

**实现策略**:

```go
// 模型路由器
type ModelRouter struct {
    localSmall  ai.LLMService  // Qwen2.5-1.5B / Phi-3-mini
    localMedium ai.LLMService  // Qwen2.5-7B (可选)
    cloud       ai.LLMService  // GPT-4 / Claude
}

func (r *ModelRouter) Route(task TaskType) ai.LLMService {
    switch task {
    case TaskIntentClassification, TaskEntityExtraction:
        return r.localSmall   // 本地小模型即可
        
    case TaskSimpleQA, TaskScheduleCreate, TaskMemoSearch:
        if r.localMedium != nil {
            return r.localMedium  // 有中模型用中模型
        }
        return r.cloud
        
    case TaskComplexReasoning, TaskLongSummarization, TaskCreative:
        return r.cloud        // 复杂任务用云端
        
    default:
        return r.cloud
    }
}
```

**ROI 分析**:

| 投入 | 产出 |
|------|------|
| 开发: ~5 人天 | API 成本降低 60-80% |
| 内存: 2-8GB | 离线可用（部分功能）|
| | 延迟降低 50%+ (简单任务) |

---

#### 3.3.2 预测性交互

**能力**: 主动预测用户需求，提前准备

```
┌─────────────────────────────────────────────────────────────────┐
│                    预测性交互系统                                 │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │                   预测引擎                               │   │
│  │                                                          │   │
│  │  时间 + 上下文 + 历史模式 → 预测用户可能需要什么          │   │
│  │                                                          │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  预测场景:                                                      │
│                                                                 │
│  ┌─────────────────┐  ┌─────────────────┐  ┌─────────────────┐ │
│  │   时间触发       │  │   内容触发       │  │   模式触发      │ │
│  │                 │  │                 │  │                 │ │
│  │ • 早上9点       │  │ • 编辑笔记时    │  │ • 每周一9点     │ │
│  │   → 今日日程    │  │   → 相关笔记    │  │   → 周报提醒    │ │
│  │                 │  │                 │  │                 │ │
│  │ • 会议前15分钟  │  │ • 搜索后       │  │ • 月底          │ │
│  │   → 会议提醒    │  │   → 快捷操作    │  │   → 月度回顾    │ │
│  └─────────────────┘  └─────────────────┘  └─────────────────┘ │
│                                                                 │
│  交互方式:                                                      │
│  • 轻量提示卡片 (非弹窗打扰)                                    │
│  • "您可能需要..." 建议                                        │
│  • 一键执行 / 忽略                                              │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

#### 3.3.3 主动提醒

**能力**: 基于日程和习惯的智能提醒

```go
// 智能提醒系统
type SmartReminder struct {
    scheduler       *ScheduleService
    preferences     *UserPreferences
    notificationSvc NotificationService
}

// 提醒策略
type ReminderStrategy struct {
    DefaultLeadTime  time.Duration // 默认提前量: 15分钟
    ImportantLead    time.Duration // 重要事项: 30分钟
    DailyDigest      time.Time     // 每日摘要: 08:00
    WeeklyPreview    time.Weekday  // 每周预览: 周日晚
}

// 智能调整提前量
func (r *SmartReminder) CalculateLeadTime(schedule *Schedule) time.Duration {
    // 基于历史数据调整
    // 例如: 用户经常迟到的会议 → 提前量增加
    avgDelay := r.preferences.GetAverageDelay(schedule.Type)
    
    base := r.strategy.DefaultLeadTime
    if schedule.IsImportant {
        base = r.strategy.ImportantLead
    }
    
    return base + avgDelay
}
```

---

## 4. 关键技术方案

### 4.1 技术架构演进

```
┌─────────────────────────────────────────────────────────────────────────┐
│                         架构演进路径                                      │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  当前架构                      Phase 1                     Phase 2/3    │
│  ──────────                   ────────                    ──────────   │
│                                                                         │
│  ChatRouter                   ChatRouter                  ChatRouter    │
│      │                            │                           │         │
│      ▼                            ▼                           ▼         │
│  Single Agent               Single Agent               Single Agent     │
│      │                            │                           │         │
│      │                     ┌──────┴──────┐             ┌──────┴──────┐  │
│      │                     │             │             │             │  │
│      │                     ▼             ▼             ▼             ▼  │
│      │                  Memory      Metrics        Memory        Model  │
│      │                  System                     System        Router │
│      ▼                     │             │             │             │  │
│    Tools                   └──────┬──────┘             └──────┬──────┘  │
│                                   ▼                           ▼         │
│                                Tools                       Tools        │
│                                   │                           │         │
│                            ResilientExec              Self-RAG + Habit  │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### 4.2 数据存储方案

```
┌─────────────────────────────────────────────────────────────────┐
│                    数据存储架构                                   │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  SQLite (单文件, 适合私人部署)                                   │
│  ├── memos.db          # 笔记数据 (已有)                        │
│  ├── schedules.db      # 日程数据 (已有)                        │
│  └── ai_assistant.db   # AI 助理数据 (新增)                     │
│      ├── episodic_memory    # 情景记忆                          │
│      ├── user_preferences   # 用户偏好                          │
│      ├── agent_metrics      # Agent 指标                        │
│      └── learned_patterns   # 学习到的模式                      │
│                                                                 │
│  预估存储:                                                       │
│  • Phase 1: ~10MB                                               │
│  • Phase 2: ~50MB                                               │
│  • Phase 3: ~100MB (含本地模型缓存)                             │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 4.3 资源消耗预估

| 阶段 | 内存增量 | CPU 增量 | 存储增量 |
|------|---------|---------|---------|
| Phase 1 | +20MB | 可忽略 | +10MB |
| Phase 2 | +50MB | +5% (后台分析) | +50MB |
| Phase 3 | +2-8GB (本地模型) | +10% | +100MB |

---

## 5. ROI 分析

### 5.1 总体 ROI 矩阵

| 阶段 | 特性 | 开发投入 | 用户价值 | ROI |
|------|------|---------|---------|-----|
| **Phase 1** | 轻量记忆系统 | 3 人天 | 跨会话记忆，减少重复 | ★★★★★ |
| | 基础评估指标 | 2 人天 | 问题可定位 | ★★★★☆ |
| | 路由准确性提升 | 3 人天 | 延迟降低，成本降低 | ★★★★★ |
| | 工具可靠性增强 | 2 人天 | 稳定性提升 | ★★★★☆ |
| **Phase 2** | 用户习惯学习 | 5 人天 | "懂你"体验 | ★★★★★ |
| | Self-RAG 优化 | 3 人天 | 答案质量提升 | ★★★★☆ |
| | 上下文增强 | 3 人天 | 对话连贯性 | ★★★★☆ |
| | Generative UI | 4 人天 | 交互体验提升 | ★★★☆☆ |
| **Phase 3** | 本地模型支持 | 5 人天 | 成本降低 60%+ | ★★★★☆ |
| | 预测性交互 | 5 人天 | 主动服务体验 | ★★★☆☆ |
| | 主动提醒 | 3 人天 | 助理感增强 | ★★★☆☆ |

### 5.2 成本节省分析

```
┌─────────────────────────────────────────────────────────────────┐
│                    API 成本节省预估                               │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  假设: 每日 50 次 AI 交互                                        │
│                                                                 │
│  当前成本:                                                       │
│  ├── 路由分类: 50 × $0.001 = $0.05/天                           │
│  ├── Agent 执行: 50 × $0.02 = $1.00/天                          │
│  └── 总计: ~$1.05/天 = ~$31.5/月                                │
│                                                                 │
│  Phase 1 后 (路由优化):                                         │
│  ├── 路由分类: 20 × $0.001 = $0.02/天 (↓60%)                    │
│  └── 总计: ~$1.02/天 = ~$30.6/月                                │
│                                                                 │
│  Phase 3 后 (本地模型):                                         │
│  ├── 路由分类: $0 (本地)                                        │
│  ├── 简单任务: $0 (本地)                                        │
│  ├── 复杂任务: 10 × $0.02 = $0.20/天                            │
│  └── 总计: ~$0.20/天 = ~$6/月 (↓80%)                            │
│                                                                 │
│  年度节省: ~$300                                                 │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 5.3 用户体验提升

| 维度 | 当前 | Phase 1 后 | Phase 2 后 | Phase 3 后 |
|------|------|-----------|-----------|-----------|
| 响应速度 (P50) | 1.5s | 1.2s | 1.0s | 0.5s |
| 任务成功率 | 85% | 90% | 93% | 95% |
| 重复询问率 | 高 | 低 | 很低 | 极低 |
| "懂我"感知 | 无 | 基础 | 良好 | 优秀 |

---

## 6. 风险与缓解

### 6.1 风险矩阵

| 风险 | 概率 | 影响 | 缓解措施 |
|------|------|------|---------|
| 本地模型质量不足 | 中 | 高 | 混合策略，复杂任务仍用云端 |
| 记忆系统性能问题 | 低 | 中 | 限制记忆条数，定期清理 |
| 用户习惯学习误判 | 中 | 低 | 提供手动纠正入口 |
| 资源消耗超预期 | 中 | 中 | 分阶段验证，及时调整 |

### 6.2 回滚策略

每个阶段的特性都设计为可独立开关:

```go
// 特性开关
type FeatureFlags struct {
    EpisodicMemory    bool // Phase 1
    EnhancedRouting   bool // Phase 1
    HabitLearning     bool // Phase 2
    SelfRAG           bool // Phase 2
    LocalModel        bool // Phase 3
    PredictiveUI      bool // Phase 3
}
```

---

## 附录

### A. 与通用路线图对比

| 通用路线图项目 | 私人助理路线图 | 变更原因 |
|---------------|---------------|---------|
| Multi-Agent + Handoffs | **不采用** | 单用户场景过度复杂 |
| 企业级 Guardrails | **简化为基础检查** | 私人场景风险低 |
| MCP Server | **延后** | 非 SaaS，无外部集成需求 |
| 完整 Evals 体系 | **简化为轻量指标** | 快速迭代即可 |
| 三层记忆架构 | **简化为两层** | 单用户无需复杂隔离 |

### B. 技术选型

| 组件 | 选型 | 备选 |
|------|------|------|
| 记忆存储 | SQLite | - |
| 本地模型 | Ollama + Qwen2.5 | llama.cpp |
| 向量检索 | sqlite-vec | - |
| 指标采集 | 嵌入式 | Prometheus (过重) |

### C. 实施检查清单

**Phase 1 检查清单**:
- [ ] 情景记忆表设计 & 实现
- [ ] 用户偏好 JSON Schema
- [ ] 轻量指标采集器
- [ ] 管理后台指标页面
- [ ] 路由关键词库扩展
- [ ] 历史模式匹配实现
- [ ] 工具重试机制
- [ ] 降级策略实现

**Phase 2 检查清单**:
- [ ] 习惯学习后台任务
- [ ] 模式识别算法
- [ ] Self-RAG 决策规则
- [ ] 上下文构建器增强
- [ ] MemoPreview 组件
- [ ] QuickActions 组件
- [ ] ProgressTracker 组件

**Phase 3 检查清单**:
- [ ] 本地模型集成 (Ollama)
- [ ] 模型路由器实现
- [ ] 预测引擎实现
- [ ] 提醒系统实现
- [ ] 通知推送集成

---

*文档版本: v1.0 | 更新时间: 2026-01-27*
